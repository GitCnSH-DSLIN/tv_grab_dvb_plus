
#include <stdio.h>
#include <stdlib.h>

u_char **huffman_word_lookup_lo[4];
u_char **huffman_word_lookup_hi[4];
int     huffman_word_lookup_size[4];
u_short *huffman_hi_bit_branch[4];
u_short *huffman_lo_bit_branch[4];
int     huffman_valid_start_code[4];


short huffman_code_check = 0x100;

//                07h
//		39h

u_char *huffman_word_dictionary[] =
{
//"\x07" "9(Including ",
"(Including ",
"(New Series)",
"(Part ",
"(Repeat)",
"(Stereo)",
"(Stereo) (Teletext)",
"(Teletext)",
"(Widescreen)",
"Action",
"Adventures",
"America",
"Animated",
"Australia",
"Away",
"BBC",
"Baby",
"Best",
"Big",
"Bill",
"Black",
"Blue",
"Breakfast",
"Britain",
"British",
"Business",
"Call",
"Cartoon",
"Channel",
"Children",
"Clock",
"Comedy",
"Cook",
"Country",
"Directed by ",
"Drama",
"East",
"Education",
"English",
"Europe",
"Extra",
"Final",
"Financial",
"For",
"French",
"From",
"George",
"Get",
"Girls",
"Golden",
"Golf",
"Good",
"Great",
"Hampshire",
"Headlines",
"Hear",
"Hill",
"Hollywood",
"Home",
"Hour",
"House",
"How",
"ITN",
"Important",
"Including",
"International",
"John",
"Last",
"Late",
"Learn",
"Little",
"Live",
"London",
"Look",
"Lunch",
"Man",
"Mark",
"Meridian",
"Michael",
"Minutes",
"More",
"Morning",
"Murder",
"Nation",
"Neighbours",
"New",
"News & Weather",
"News And Weather",
"Paul",
"Plus",
"Prayer",
"Present",
"Presented by",
"Quiz",
"Regional",
"Represent",
"Resource",
"Review",
"Richard",
"School",
"Series",
"Service",
"Show",
"Smith",
"South",
"Sport",
"Star",
"Street",
"TV",
"Teaching",
"The",
"Today",
"Tonight",
"Weather",
"Western",
"Westminster",
"William",
"With",
"World",
"about",
"action-packed",
"adventure",
"afternoon",
"alert",
"all-star cast",
"and",
"anywhere",
"audience",
"based",
"book",
"business",
"but",
"celebrity",
"chance",
"chat",
"child",
"classic",
"consumer",
"contestants",
"continues",
"controversial",
"dealer",
"deliver",
"discuss",
"document",
"drama",
"edition",
"education",
"events",
"every",
"excellent",
"eyed",
"family",
"famous",
"featur",
"film",
"football",
"for",
"from",
"general knowledge",
"get",
"guest",
"guests",
"has",
"have",
"headline",
"her",
"his",
"home and abroad",
"host",
"how",
"in",
"including",
"international",
"interview",
"introduce",
"investigat",
"invites",
"issue",
"knowledge",
"life",
"live",
"look",
"magazine",
"meets ",
"morning",
"morning magazine",
"music",
"near",
"network",
"new",
"new series",
"night",
"of",
"on",
"onight",
"out",
"over",
"part",
"people",
"phone",
"poli",
"police",
"political chat show",
"popular",
"presented by ",
"programm",
"quiz",
"reconstruction",
"report",
"review",
"school",
"series",
"short ",
"show",
"some",
"starring",
"stars",
"stories",
"story",
"studio",
"surprise",
"teller",
"that",
"the",
"their",
"them",
"they",
"this",
"through",
"to",
"top",
"trans",
"under",
"up",
"very",
"video",
"view",
"vintage",
"visit",
"was",
"way",
"week",
"well",
"what",
"when",
"which",
"while",
"who",
"will",
"win",
"with",
"words",
"world",
"written",
"year",
"you",
NULL
};

short huffman_table_size = 0x1ff;

u_short huffman_table[] =
{
0x0200,
0x0400,
0x0600,
0xDFFF,
0x0900,
0x0B00,
0x0D00,
0x0E00,
0x1000,
0x1100,
0x8BFF,
0x1200,
0x8DFF,
0x8CFF,
0x1500,
0x1600,
0x93FF,
0x1900,
0x1A00,
0x1C00,
0x1E00,
0x1F00,
0x2000,
0x2100,
0x2200,
0x2300,
0x2400,
0x88FF,
0x2600,
0xD1FF,
0x2800,
0x9DFF,
0xD3FF,
0x89FF,
0x2D00,
0x94FF,
0x3000,
0x3100,
0xF6FF,
0x3300,
0x3500,
0xBEFF,
0xA8FF,
0x3900,
0x3A00,
0x3B00,
0xD8FF,
0xBCFF,
0xBDFF,
0x3F00,
0xADFF,
0x4100,
0xCFFF,
0x4400,
0x4500,
0x4600,
0x4800,
0xB9FF,
0x4A00,
0xB8FF,
0xB3FF,
0x4D00,
0xB0FF,
0x4E00,
0x4F00,
0xCAFF,
0xFCFE,
0x5200,
0xBAFF,
0xF9FE,
0x85FF,
0x5600,
0xD6FF,
0x5900,
0xCDFF,
0xC8FF,
0x5B00,
0x5C00,
0xCBFF,
0x5E00,
0x9FFF,
0xC5FF,
0x6100,
0x95FF,
0x00FE,
0xA6FF,
0x6500,
0x6600,
0xC7FF,
0x6900,
0x6A00,
0x6B00,
0xDEFF,
0xC4FF,
0x6F00,
0x7000,
0x7200,
0x7400,
0x7500,
0x7700,
0x7900,
0x7A00,
0xDEFE,
0xD5FF,
0x7E00,
0x8000,
0x01FE,
0x8300,
0x8500,
0xEAFE,
0x8800,
0xA5FF,
0xC1FF,
0x8B00,
0xE8FE,
0x8D00,
0xB9FE,
0x9000,
0xEBFE,
0x9200,
0xD2FE,
0xE9FE,
0x9500,
0xCDFE,
0xC0FE,
0x9600,
0xC6FE,
0xD3FE,
0xECFE,
0xD1FE,
0xC4FE,
0xC8FE,
0xE7FE,
0xF5FE,
0xD9FE,
0x9A00,
0xC2FE,
0xF2FE,
0xC9FE,
0xB8FE,
0xBFFE,
0xCCFE,
0xFEFE,
0x9E00,
0xF0FE,
0xB7FE,
0xEEFE,
0xFFFE,
0xD7FE,
0xE5FE,
0xBBFE,
0xD0FE,
0xBCFE,
0xD0FF,
0xCBFE,
0xE0FE,
0xDFFE,
0xB6FE,
0xD6FE,
0xA200,
0xF8FE,
0xA300,
0xA400,
0xA2FF,
0xA500,
0xA600,
0xA800,
0xAA00,
0xAC00,
0xAE00,
0xB000,
0xB200,
0xB400,
0xB600,
0xB800,
0xBA00,
0xBC00,
0xBE00,
0xC000,
0xC200,
0xC400,
0xC600,
0xC800,
0xCA00,
0xCC00,
0xCE00,
0xD000,
0xD200,
0xD400,
0xD600,
0xD800,
0xDA00,
0xDC00,
0xDE00,
0xE000,
0xE200,
0xE400,
0xE600,
0xE800,
0xEA00,
0xEC00,
0xEE00,
0xF000,
0xF200,
0xF400,
0xF600,
0xF800,
0xFA00,
0xFC00,
0xFE00,
0x0001,
0x0201,
0x0401,
0x0601,
0x0801,
0x0A01,
0x0C01,
0x0E01,
0x1001,
0x1201,
0x1401,
0x1601,
0x1801,
0x1A01,
0x1C01,
0x1E01,
0x2001,
0x2201,
0x2401,
0x2601,
0x2801,
0x2A01,
0x2C01,
0x2E01,
0x3001,
0x3201,
0x3401,
0x3601,
0x3801,
0x3A01,
0x3C01,
0x3E01,
0x4001,
0x4201,
0x4401,
0x4601,
0x4801,
0x4A01,
0x4C01,
0x4E01,
0x5001,
0x5201,
0x5401,
0x5601,
0x5801,
0x5A01,
0x5C01,
0x5E01,
0x6001,
0x6201,
0x6401,
0x6601,
0x6801,
0x6A01,
0x6C01,
0x6E01,
0x7001,
0x7201,
0x7401,
0x7601,
0x7801,
0x7A01,
0x7C01,
0x7E01,
0x8001,
0x8201,
0x8401,
0x8601,
0x8801,
0x8A01,
0x8C01,
0x8E01,
0x9001,
0x9201,
0x9401,
0x9601,
0x9801,
0x9A01,
0x9C01,
0x9E01,
0xA001,
0xA201,
0xA401,
0xA601,
0xA801,
0xAA01,
0xAC01,
0xAE01,
0xB001,
0xB201,
0xB401,
0xB601,
0xB801,
0xBA01,
0xBC01,
0xBE01,
0xC001,
0xC201,
0xC401,
0xC601,
0xC801,
0xCA01,
0xCC01,
0xCE01,
0xD001,
0xD201,
0xD401,
0xD601,
0xD801,
0xDA01,
0xDC01,
0xDE01,
0xE001,
0xE201,
0xE401,
0xE601,
0xE801,
0xEA01,
0xEC01,
0xEE01,
0xF001,
0xF201,
0xF401,
0xF601,
0xF801,
0xFA01,
0xFC01,
0xFE01,
0x03FE,
0x05FE,
0x07FE,
0x09FE,
0x0BFE,
0x0DFE,
0x0FFE,
0x11FE,
0x13FE,
0x15FE,
0x17FE,
0x19FE,
0x1BFE,
0x1DFE,
0x1FFE,
0x21FE,
0x23FE,
0x25FE,
0x27FE,
0x29FE,
0x2BFE,
0x2DFE,
0x2FFE,
0x31FE,
0x33FE,
0x35FE,
0x37FE,
0x39FE,
0x3BFE,
0x3DFE,
0x3FFE,
0x41FE,
0x43FE,
0x45FE,
0x47FE,
0x49FE,
0x4BFE,
0x4DFE,
0x4FFE,
0x51FE,
0x53FE,
0x55FE,
0x57FE,
0x59FE,
0x5BFE,
0x5DFE,
0x5FFE,
0x61FE,
0x63FE,
0x65FE,
0x67FE,
0x69FE,
0x6BFE,
0x6DFE,
0x6FFE,
0x71FE,
0x73FE,
0x75FE,
0x77FE,
0x79FE,
0x7BFE,
0x7DFE,
0x7FFE,
0x81FE,
0x83FE,
0x85FE,
0x87FE,
0x89FE,
0x8BFE,
0x8DFE,
0x8FFE,
0x91FE,
0x93FE,
0x95FE,
0x97FE,
0x99FE,
0x9BFE,
0x9DFE,
0x9FFE,
0xA1FE,
0xA3FE,
0xA5FE,
0xA7FE,
0xA9FE,
0xABFE,
0xADFE,
0xAFFE,
0xB1FE,
0x01FF,
0x03FF,
0x05FF,
0x07FF,
0x09FF,
0x0BFF,
0x0DFF,
0x0FFF,
0x11FF,
0x13FF,
0x15FF,
0x17FF,
0x19FF,
0x1BFF,
0x1DFF,
0x1FFF,
0x21FF,
0x23FF,
0x25FF,
0x27FF,
0x29FF,
0x2BFF,
0x2DFF,
0x2FFF,
0x31FF,
0x33FF,
0x35FF,
0x37FF,
0x39FF,
0x3BFF,
0x3DFF,
0x3FFF,
0x41FF,
0x43FF,
0x45FF,
0x47FF,
0x49FF,
0x4BFF,
0x4DFF,
0x4FFF,
0x51FF,
0x53FF,
0x55FF,
0x57FF,
0x59FF,
0x5BFF,
0x5DFF,
0x5FFF,
0x61FF,
0x64FF,
0x66FF,
0x68FF,
0x6AFF,
0x6CFF,
0x6EFF,
0x70FF,
0x72FF,
0x74FF,
0x76FF,
0x78FF,
0x7AFF,
0x7CFF,
0x7EFF,
0x80FF,
0x82FF,
0x84FF,
0xA1FF,
0xC2FF,
0xDAFF,
0xDDFF,
0xE1FF,
0xE3FF,
0xE5FF,
0xE7FF,
0xE9FF,
0xEBFF,
0xEDFF,
0xEFFF,
0xF1FF,
0xF3FF,
0xF7FF,
0xF9FF,
0xFBFF,
0xFDFF,
0xFFFF,
0x0100,
0x0300,
0x0500,
0x0700,
0x0800,
0x0A00,
0x0C00,
0x9AFF,
0x0F00,
0x9EFF,
0x91FF,
0x96FF,
0x90FF,
0x1300,
0x1400,
0x97FF,
0x1700,
0x1800,
0x9BFF,
0x1B00,
0x1D00,
0x9CFF,
0x8AFF,
0x92FF,
0x98FF,
0x99FF,
0x86FF,
0x8FFF,
0x2500,
0xF5FF,
0x2700,
0x2900,
0x2A00,
0x2B00,
0x2C00,
0x2E00,
0x2F00,
0xABFF,
0xACFF,
0x3200,
0x3400,
0x3600,
0x3700,
0x3800,
0xD2FF,
0xB2FF,
0x3C00,
0x3D00,
0x3E00,
0xAFFF,
0xB1FF,
0x4000,
0x4200,
0x4300,
0xBBFF,
0xCEFF,
0x4700,
0xB7FF,
0x4900,
0x4B00,
0x4C00,
0xFBFE,
0xFAFE,
0xB5FF,
0x87FF,
0x5000,
0xB4FF,
0x5100,
0xB6FF,
0x5300,
0x5400,
0x5500,
0x5700,
0x5800,
0xC9FF,
0x5A00,
0xCCFF,
0xC6FF,
0x5D00,
0xA9FF,
0x5F00,
0x6000,
0xD7FF,
0x6200,
0x6300,
0x6400,
0xAAFF,
0x8EFF,
0x6700,
0x6800,
0xBEFE,
0xD9FF,
0x6C00,
0x6D00,
0x6E00,
0xC0FF,
0x7100,
0x7300,
0xD5FE,
0x7600,
0x7800,
0xB3FE,
0x7B00,
0x7C00,
0x7D00,
0x7F00,
0x8100,
0x8200,
0x8400,
0x8600,
0x8700,
0x8900,
0x8A00,
0xC3FF,
0xFDFE,
0x8C00,
0x8E00,
0x8F00,
0x9100,
0xB2FE,
0x9300,
0xE6FE,
0x9400,
0xC3FE,
0xEDFE,
0xAEFF,
0xB5FE,
0xCAFE,
0xDCFE,
0x9700,
0x9800,
0xB4FE,
0xDDFE,
0xF3FE,
0x9900,
0xE3FE,
0x9B00,
0xEFFE,
0x9C00,
0xD4FE,
0xBDFE,
0xC5FE,
0xE1FE,
0x9D00,
0xE2FE,
0xF6FE,
0xD8FE,
0xF1FE,
0x9F00,
0xE4FE,
0xBAFE,
0xCFFE,
0xA000,
0xDAFE,
0xC1FE,
0xCEFE,
0xF4FE,
0xA100,
0xC7FE,
0xF7FE,
0xDBFE,
0xA7FF,
0xDBFF,
0x63FF,
0xA4FF,
0xBFFF,
0xA700,
0xA900,
0xAB00,
0xAD00,
0xAF00,
0xB100,
0xB300,
0xB500,
0xB700,
0xB900,
0xBB00,
0xBD00,
0xBF00,
0xC100,
0xC300,
0xC500,
0xC700,
0xC900,
0xCB00,
0xCD00,
0xCF00,
0xD100,
0xD300,
0xD500,
0xD700,
0xD900,
0xDB00,
0xDD00,
0xDF00,
0xE100,
0xE300,
0xE500,
0xE700,
0xE900,
0xEB00,
0xED00,
0xEF00,
0xF100,
0xF300,
0xF500,
0xF700,
0xF900,
0xFB00,
0xFD00,
0xFF00,
0x0101,
0x0301,
0x0501,
0x0701,
0x0901,
0x0B01,
0x0D01,
0x0F01,
0x1101,
0x1301,
0x1501,
0x1701,
0x1901,
0x1B01,
0x1D01,
0x1F01,
0x2101,
0x2301,
0x2501,
0x2701,
0x2901,
0x2B01,
0x2D01,
0x2F01,
0x3101,
0x3301,
0x3501,
0x3701,
0x3901,
0x3B01,
0x3D01,
0x3F01,
0x4101,
0x4301,
0x4501,
0x4701,
0x4901,
0x4B01,
0x4D01,
0x4F01,
0x5101,
0x5301,
0x5501,
0x5701,
0x5901,
0x5B01,
0x5D01,
0x5F01,
0x6101,
0x6301,
0x6501,
0x6701,
0x6901,
0x6B01,
0x6D01,
0x6F01,
0x7101,
0x7301,
0x7501,
0x7701,
0x7901,
0x7B01,
0x7D01,
0x7F01,
0x8101,
0x8301,
0x8501,
0x8701,
0x8901,
0x8B01,
0x8D01,
0x8F01,
0x9101,
0x9301,
0x9501,
0x9701,
0x9901,
0x9B01,
0x9D01,
0x9F01,
0xA101,
0xA301,
0xA501,
0xA701,
0xA901,
0xAB01,
0xAD01,
0xAF01,
0xB101,
0xB301,
0xB501,
0xB701,
0xB901,
0xBB01,
0xBD01,
0xBF01,
0xC101,
0xC301,
0xC501,
0xC701,
0xC901,
0xCB01,
0xCD01,
0xCF01,
0xD101,
0xD301,
0xD501,
0xD701,
0xD901,
0xDB01,
0xDD01,
0xDF01,
0xE101,
0xE301,
0xE501,
0xE701,
0xE901,
0xEB01,
0xED01,
0xEF01,
0xF101,
0xF301,
0xF501,
0xF701,
0xF901,
0xFB01,
0xFD01,
0x02FE,
0x04FE,
0x06FE,
0x08FE,
0x0AFE,
0x0CFE,
0x0EFE,
0x10FE,
0x12FE,
0x14FE,
0x16FE,
0x18FE,
0x1AFE,
0x1CFE,
0x1EFE,
0x20FE,
0x22FE,
0x24FE,
0x26FE,
0x28FE,
0x2AFE,
0x2CFE,
0x2EFE,
0x30FE,
0x32FE,
0x34FE,
0x36FE,
0x38FE,
0x3AFE,
0x3CFE,
0x3EFE,
0x40FE,
0x42FE,
0x44FE,
0x46FE,
0x48FE,
0x4AFE,
0x4CFE,
0x4EFE,
0x50FE,
0x52FE,
0x54FE,
0x56FE,
0x58FE,
0x5AFE,
0x5CFE,
0x5EFE,
0x60FE,
0x62FE,
0x64FE,
0x66FE,
0x68FE,
0x6AFE,
0x6CFE,
0x6EFE,
0x70FE,
0x72FE,
0x74FE,
0x76FE,
0x78FE,
0x7AFE,
0x7CFE,
0x7EFE,
0x80FE,
0x82FE,
0x84FE,
0x86FE,
0x88FE,
0x8AFE,
0x8CFE,
0x8EFE,
0x90FE,
0x92FE,
0x94FE,
0x96FE,
0x98FE,
0x9AFE,
0x9CFE,
0x9EFE,
0xA0FE,
0xA2FE,
0xA4FE,
0xA6FE,
0xA8FE,
0xAAFE,
0xACFE,
0xAEFE,
0xB0FE,
0x00FF,
0x02FF,
0x04FF,
0x06FF,
0x08FF,
0x0AFF,
0x0CFF,
0x0EFF,
0x10FF,
0x12FF,
0x14FF,
0x16FF,
0x18FF,
0x1AFF,
0x1CFF,
0x1EFF,
0x20FF,
0x22FF,
0x24FF,
0x26FF,
0x28FF,
0x2AFF,
0x2CFF,
0x2EFF,
0x30FF,
0x32FF,
0x34FF,
0x36FF,
0x38FF,
0x3AFF,
0x3CFF,
0x3EFF,
0x40FF,
0x42FF,
0x44FF,
0x46FF,
0x48FF,
0x4AFF,
0x4CFF,
0x4EFF,
0x50FF,
0x52FF,
0x54FF,
0x56FF,
0x58FF,
0x5AFF,
0x5CFF,
0x5EFF,
0x60FF,
0x62FF,
0x65FF,
0x67FF,
0x69FF,
0x6BFF,
0x6DFF,
0x6FFF,
0x71FF,
0x73FF,
0x75FF,
0x77FF,
0x79FF,
0x7BFF,
0x7DFF,
0x7FFF,
0x81FF,
0x83FF,
0xA0FF,
0xA3FF,
0xD4FF,
0xDCFF,
0xE0FF,
0xE2FF,
0xE4FF,
0xE6FF,
0xE8FF,
0xEAFF,
0xECFF,
0xEEFF,
0xF0FF,
0xF2FF,
0xF4FF,
0xF8FF,
0xFAFF,
0xFCFF,
0xFEFF,
0
};

u_char* huffman_word_dictionary_table[768];

void huffman_init_decode_tree(int first_index, u_short* pTableLo, u_short* pTableHi, int table_size);
void huffman_init_word_decode_tree(int insert_index, u_char ** table_lo_ptr, u_char ** table_hi_ptr, int size);
int init_huffman();

int init_huffman()
{
    //u_char ** dst_table_ptr;

    //arg_4 = &aControl_init_c;
    //huffman_table_size_ = ((*(BYTE*)huffman_code_check << 8) + *(BYTE*)(huffman_code_check + 1)) & 1023;
    if (huffman_table_size > 768)
    {
        //CAErrorMessageBox(arg_0, &arg_4 [ 4], 134, arg_4);
        //AbortReportGuruMeditation(arg_0, arg_4 [ 16], CAErrorMessageBox(arg_0, &arg_4 [ 4], 134, arg_4));
	return -1;
    }
    //u_char * huffman_word_str_ptr1 = (u_char*)huffman_word_dictionary;
    u_char ** huffman_word_str_ptr2 = huffman_word_dictionary;
    //dst_table_ptr = huffman_word_dictionary_table;
    huffman_word_dictionary_table[0] = *huffman_word_str_ptr2++;
    int dst_index = 1;
    if (huffman_table_size > 1)
    {
#if 1
        while (*huffman_word_str_ptr2) 
	{
            huffman_word_dictionary_table [ dst_index++ ] = *huffman_word_str_ptr2++;
	};
#else
        do {
            if (*huffman_word_str_ptr2)
            {
                do {
                    huffman_word_str_ptr2++;
                } while (*huffman_word_str_ptr2); /* end of loop */
            }
            huffman_word_str_ptr2++;
            huffman_word_dictionary_table [ dst_index++ ] = huffman_word_str_ptr2;
        } while (huffman_table_size > dst_index); /* end of loop */
#endif
    }
    huffman_init_word_decode_tree(0, huffman_word_dictionary, huffman_word_dictionary_table, huffman_table_size);
    //tmp_huffman_table_size_ = huffman_table_size_;
    //huffman_table_size_ = ((*(BYTE*)huffman_table_size << 8) + *(BYTE*)(huffman_table_size + 1)) & 1023;
    if (huffman_table_size > 1023)
    {
        //CAErrorMessageBox(arg_0, &arg_4 [ 4], 155, arg_4);
        //AbortReportGuruMeditation(arg_0, arg_4 [ 16], CAErrorMessageBox(arg_0, &arg_4 [ 4], 155, arg_4));
	return -1;
    }
    huffman_init_decode_tree(0, 
	    &huffman_table[0],
	    &huffman_table[ huffman_table_size ],
	    //huffman_table_size + 2, 
	    //(WORD*)&arg_4 [ huffman_table_size ], 
	    huffman_table_size);
    return 0;
}

void huffman_init_word_decode_tree(int insert_index, u_char ** table_lo_ptr, u_char ** table_hi_ptr, int size)
{

    if ((insert_index > -1) && (insert_index <= 3))
    {
        huffman_word_lookup_lo [ insert_index] = table_lo_ptr;
        huffman_word_lookup_hi [ insert_index] = table_hi_ptr;
        if (!table_hi_ptr | !table_lo_ptr)
        {
            huffman_word_lookup_size [ insert_index] = 0;
        }
        else
        {
            huffman_word_lookup_size [ insert_index] = size;
        }
    }
}

void huffman_init_decode_tree(int first_index, u_short* pTableLo, u_short* pTableHi, int table_size)
{
    short var_8;
    int index;

    var_8 = 0;
    if ((first_index > -1) && (first_index <= 3))
    {
        huffman_lo_bit_branch [ first_index] = pTableLo;
        huffman_hi_bit_branch [ first_index] = pTableHi;
        if (!pTableLo | !pTableHi)
        {
            huffman_valid_start_code [ first_index ] = 0;
        }
        else
        {
            huffman_valid_start_code [ first_index ] = table_size;
        }
	// endian test for little endian
	// swap bytes if it is
        var_8 = 0xff0;
        if (*(u_char*)&var_8 == 0xf0)
        {
            index = 0;
            if (table_size > 0)
            {
                do {
                    u_short *p = &pTableLo [ index];
                    *p = ((*p >> 8) & 0xff) + ((*p & 0xff) << 8);
                    p = &pTableHi [ index];
                    *p = ((*p >> 8) & 0xff) + ((*p & 0xff) << 8);
                    index++;
                } while (table_size > index); /* end of loop */
            }
        }
    }
}

int huffman_decode(u_char* src_ptr, int src_len, u_char * dest_ptr, int dest_len)
{
    int bit_mask;
    int dict_index;
    int current_byte_to_decode;
    u_short * huffman_lo_bit_branch_ptr;
    u_short * huffman_hi_bit_branch_ptr;
    int dest_len1;
    int dest_count;
    int src_index;

    if (dest_len && dest_ptr)
    {
        if (src_len && src_ptr)
        {
            dict_index = *src_ptr >> 6;
            if ((dict_index < 4) && huffman_valid_start_code [ dict_index])
            {
                huffman_hi_bit_branch_ptr = huffman_hi_bit_branch [ dict_index];
                huffman_lo_bit_branch_ptr = huffman_lo_bit_branch [ dict_index];
                current_byte_to_decode = *src_ptr;
                bit_mask = 32;
                src_index = 0;
                dest_count = 0;
                dest_len1 = dest_len + -1;
                short result_code = 0;
                if (dest_len1 > 0)
                {
                    do {
                        if (current_byte_to_decode & bit_mask)
                        {
                            result_code = huffman_hi_bit_branch_ptr [ result_code ];
                        }
                        else
                        {
                            result_code = huffman_lo_bit_branch_ptr [ result_code ];
                        }
                        if (result_code < 0)
                        {
                            result_code = -1 - result_code;
                            if (result_code < 256)
                            {
                                *dest_ptr = result_code;
                                dest_ptr++;
                                dest_count++;
                            }
                            else
                            {
				u_char * char_ptr = huffman_word_lookup_hi[ dict_index ][result_code - 0x100 ];
                                //result_code_dest_len = **huffman_word_lookup_hi [ dict_index] [ &result_code [ -64]];
                                while ((dest_len1 > dest_count) && *char_ptr)
                                {
loc_40130C11:
                                    *dest_ptr++ = *char_ptr++;
                                    dest_count++;
                                }
                            }
			    result_code = 0;
                        }
                        bit_mask = (((bit_mask < 0) + bit_mask) >> 1) & 0xff;
                        if (!bit_mask)
                        {
                            src_index++;
                            src_ptr++;
                            if (src_len > src_index)
                            {
                                current_byte_to_decode = *src_ptr;
                                bit_mask = 128;
                            }
                            else
                            {
				break;
                            }
                        }
                    } while (dest_len1 > dest_count); /* end of loop */
                }
		*dest_ptr = 0;
		return dest_count + 1;
            }
            return 0;
        }
        return 0;
    }
    return 0;
}

u_char test1[] = {
//  0x1d, 0x01, 0x11, 0xcf, 
  0x2a, 0xe3, 0x01, 0xcc
, 0x9f, 0x4a, 0xf3, 0x2d, 0xe9, 0xcc, 0xb5, 0xfe
, 0x0a, 0x1b, 0x06, 0xab, 0x8c, 0x11, 0x34, 0xd2
, 0x9a, 0xae, 0x30, 0x68, 0xd6, 0x68, 0xb4, 0x33
, 0x50, 0xed, 0x25, 0x6f, 0xc0, 0xc8, 0xd3, 0xc3
, 0x55, 0xc6, 0x0d, 0x1a, 0xae, 0x30, 0x62, 0xd5
, 0x71, 0x82, 0x2e, 0x23, 0xe6, 0x06, 0xab, 0x8c
, 0x23, 0x70, 0xe6, 0x3e, 0xab, 0x8c, 0x09, 0x35
, 0xa5, 0xc2, 0x5f, 0x55, 0xc6, 0x11, 0xba, 0xea
, 0xc1, 0x63, 0x55, 0xc3, 0xaa, 0xe3, 0x3d, 0x57
, 0x8d, 0xb9, 0xab, 0x98, 0x1e, 0x19, 0x5b, 0x7c
, 0x82, 0x3a, 0xae, 0x30, 0x44, 0xd6, 0x6b, 0x55
, 0xc6, 0x11, 0xbb, 0x9b, 0x99, 0x87, 0xea, 0xb8
, 0xc2, 0x1f, 0x03, 0x23, 0x4f, 0xd5, 0x71, 0x83
, 0x46, 0xab, 0x8c, 0x18, 0xb5, 0x9a, 0xc3, 0x4b
, 0xb6, 0xab, 0x8c, 0x23, 0x70, 0xd2, 0xdc, 0xdf
, 0xb6, 0xab, 0x87, 0x55, 0xc6, 0x7a, 0xaf, 0x1b
, 0x73, 0x45, 0xee, 0x85, 0xa0, 0x83, 0x4d, 0x29
, 0xaa, 0xe3, 0x01, 0xed, 0x57, 0x18, 0x43, 0xea
, 0xb8, 0xc1, 0x8b, 0xb5
};

int main(int argc, char * argv[])
{
    init_huffman();

    u_char realbuf[2048];
    u_char *buf = test1;
    int buflen = sizeof(test1);
    int isStdin = 0;
    FILE* file = NULL;
    if (argc == 2)
    {
	if ((argv[1],"-")==0)
	{
	    isStdin = 1;
	    file = stdin;
	}
	else
	{
	    file = fopen(argv[1],"rb");
	}
    }
    if (file)
    {
	buf = realbuf;
	buflen = fread(realbuf,1,sizeof(realbuf),file);
	if (!isStdin)
	    fclose(file);
    }

    u_char output[2048];
    huffman_decode( buf, buflen, output, sizeof(output));

    printf("%s\n", output);
    return 0;
}

// vim: foldmethod=marker ts=8 sw=4
